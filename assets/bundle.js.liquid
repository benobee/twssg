/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 21);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n *\r\n * @public\r\n * @namespace Events\r\n * @description pub sub design pattern\r\n *\r\n */\n\nvar Events = {\n  topics: {},\n\n  subscribe: function subscribe(topic, listener) {\n    // create the topic if not yet created\n    if (!this.topics[topic]) {\n      this.topics[topic] = [];\n    }\n\n    // add the listener\n    this.topics[topic].push(listener);\n  },\n  publish: function publish(topic, data) {\n    // return if the topic doesn't exist, or there are no listeners\n    if (!this.topics[topic] || this.topics[topic].length < 1) {\n      return;\n    }\n\n    // send the event to all listeners\n    this.topics[topic].forEach(function (listener) {\n      listener = listener(data || {});\n    });\n  }\n};\n\nexports.default = Events;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/events/events.js\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/events/events.js?");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, Promise, global) {var require;/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   3.3.1\n */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  return typeof x === 'function' || typeof x === 'object' && x !== null;\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nvar _isArray = undefined;\nif (!Array.isArray) {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n} else {\n  _isArray = Array.isArray;\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = undefined;\nvar customSchedulerFn = undefined;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  return function () {\n    vertxNext(flush);\n  };\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var r = require;\n    var vertx = __webpack_require__(20);\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = undefined;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var _arguments = arguments;\n\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n  if (_state) {\n    (function () {\n      var callback = _arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    })();\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  _resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(16);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar GET_THEN_ERROR = new ErrorObject();\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    GET_THEN_ERROR.error = error;\n    return GET_THEN_ERROR;\n  }\n}\n\nfunction tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        _resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      _reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      _reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    _reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return _resolve(promise, value);\n    }, function (reason) {\n      return _reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$) {\n  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$ === GET_THEN_ERROR) {\n      _reject(promise, GET_THEN_ERROR.error);\n    } else if (then$$ === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$)) {\n      handleForeignThenable(promise, maybeThenable, then$$);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction _resolve(promise, value) {\n  if (promise === value) {\n    _reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction _reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = undefined,\n      callback = undefined,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction ErrorObject() {\n  this.error = null;\n}\n\nvar TRY_CATCH_ERROR = new ErrorObject();\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = undefined,\n      error = undefined,\n      succeeded = undefined,\n      failed = undefined;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      _reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n      _resolve(promise, value);\n    } else if (failed) {\n      _reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      _reject(promise, value);\n    }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      _resolve(promise, value);\n    }, function rejectPromise(reason) {\n      _reject(promise, reason);\n    });\n  } catch (e) {\n    _reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction Enumerator(Constructor, input) {\n  this._instanceConstructor = Constructor;\n  this.promise = new Constructor(noop);\n\n  if (!this.promise[PROMISE_ID]) {\n    makePromise(this.promise);\n  }\n\n  if (isArray(input)) {\n    this._input = input;\n    this.length = input.length;\n    this._remaining = input.length;\n\n    this._result = new Array(this.length);\n\n    if (this.length === 0) {\n      fulfill(this.promise, this._result);\n    } else {\n      this.length = this.length || 0;\n      this._enumerate();\n      if (this._remaining === 0) {\n        fulfill(this.promise, this._result);\n      }\n    }\n  } else {\n    _reject(this.promise, validationError());\n  }\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n};\n\nEnumerator.prototype._enumerate = function () {\n  var length = this.length;\n  var _input = this._input;\n\n  for (var i = 0; this._state === PENDING && i < length; i++) {\n    this._eachEntry(_input[i], i);\n  }\n};\n\nEnumerator.prototype._eachEntry = function (entry, i) {\n  var c = this._instanceConstructor;\n  var resolve$$ = c.resolve;\n\n  if (resolve$$ === resolve) {\n    var _then = getThen(entry);\n\n    if (_then === then && entry._state !== PENDING) {\n      this._settledAt(entry._state, i, entry._result);\n    } else if (typeof _then !== 'function') {\n      this._remaining--;\n      this._result[i] = entry;\n    } else if (c === Promise) {\n      var promise = new c(noop);\n      handleMaybeThenable(promise, entry, _then);\n      this._willSettleAt(promise, i);\n    } else {\n      this._willSettleAt(new c(function (resolve$$) {\n        return resolve$$(entry);\n      }), i);\n    }\n  } else {\n    this._willSettleAt(resolve$$(entry), i);\n  }\n};\n\nEnumerator.prototype._settledAt = function (state, i, value) {\n  var promise = this.promise;\n\n  if (promise._state === PENDING) {\n    this._remaining--;\n\n    if (state === REJECTED) {\n      _reject(promise, value);\n    } else {\n      this._result[i] = value;\n    }\n  }\n\n  if (this._remaining === 0) {\n    fulfill(promise, this._result);\n  }\n};\n\nEnumerator.prototype._willSettleAt = function (promise, i) {\n  var enumerator = this;\n\n  subscribe(promise, undefined, function (value) {\n    return enumerator._settledAt(FULFILLED, i, value);\n  }, function (reason) {\n    return enumerator._settledAt(REJECTED, i, reason);\n  });\n};\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  _reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {function} resolver\n  Useful for tooling.\n  @constructor\n*/\nfunction Promise(resolver) {\n  this[PROMISE_ID] = nextId();\n  this._result = this._state = undefined;\n  this._subscribers = [];\n\n  if (noop !== resolver) {\n    typeof resolver !== 'function' && needsResolver();\n    this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n  }\n}\n\nPromise.all = all;\nPromise.race = race;\nPromise.resolve = resolve;\nPromise.reject = reject;\nPromise._setScheduler = setScheduler;\nPromise._setAsap = setAsap;\nPromise._asap = asap;\n\nPromise.prototype = {\n  constructor: Promise,\n\n  /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise's eventual value or the\n    reason why the promise cannot be fulfilled.\n  \n    ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n  \n    Chaining\n    --------\n  \n    The return value of `then` is itself a promise.  This second, 'downstream'\n    promise is resolved with the return value of the first promise's fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n  \n    ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return 'default name';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n      // will be `'default name'`\n    });\n  \n    findUser().then(function (user) {\n      throw new Error('Found user, but still unhappy');\n    }, function (reason) {\n      throw new Error('`findUser` rejected and we're unhappy');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n  \n    ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException('Upstream error');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n  \n    Assimilation\n    ------------\n  \n    Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user's comments are now available\n    });\n    ```\n  \n    If the assimliated promise rejects, then the downstream promise will also reject.\n  \n    ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we'll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we'll have the reason here\n    });\n    ```\n  \n    Simple Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let result;\n  \n    try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n  \n    Advanced Example\n    --------------\n  \n    Synchronous Example\n  \n    ```javascript\n    let author, books;\n  \n    try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n  \n    Errback Example\n  \n    ```js\n  \n    function foundBooks(books) {\n  \n    }\n  \n    function failure(reason) {\n  \n    }\n  \n    findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n  \n    Promise Example;\n  \n    ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n  */\n  then: then,\n\n  /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n  \n    ```js\n    function findAuthor(){\n      throw new Error('couldn't find that author');\n    }\n  \n    // synchronous\n    try {\n      findAuthor();\n    } catch(reason) {\n      // something went wrong\n    }\n  \n    // async with promises\n    findAuthor().catch(function(reason){\n      // something went wrong\n    });\n    ```\n  \n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n  */\n  'catch': function _catch(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nfunction polyfill() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('polyfill failed because global object is unavailable in this environment');\n        }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n        var promiseToString = null;\n        try {\n            promiseToString = Object.prototype.toString.call(P.resolve());\n        } catch (e) {\n            // silently ignored\n        }\n\n        if (promiseToString === '[object Promise]' && !P.cast) {\n            return;\n        }\n    }\n\n    local.Promise = Promise;\n}\n\npolyfill();\n// Strange compat..\nPromise.polyfill = polyfill;\nPromise.Promise = Promise;\n\nreturn Promise;\n\n})));\n//# sourceMappingURL=es6-promise.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18), __webpack_require__(1), __webpack_require__(19)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/es6-promise/dist/es6-promise.js\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/es6-promise/dist/es6-promise.js?");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _core = __webpack_require__(8);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// import { Collection } from './src/core/storage/index';\n// import SQS from './src/sqs';\n// import { Component } from 'component-literal/index';\n\n//build the site object\nvar Site_Build = function () {\n\tfunction Site_Build() {\n\t\t_classCallCheck(this, Site_Build);\n\n\t\tthis.methods();\n\t}\n\n\t_createClass(Site_Build, [{\n\t\tkey: 'methods',\n\t\tvalue: function methods() {\n\t\t\t//FAQ\n\n\t\t\tvar faq = document.querySelectorAll('#shopify-section-1490305118107 h3');\n\n\t\t\tfaq.forEach(function (node) {\n\t\t\t\t(0, _core.$)(node.nextElementSibling).data(\"hidden\", true);\n\n\t\t\t\tnode.addEventListener(\"click\", function (e) {\n\t\t\t\t\tvar text = e.currentTarget.nextElementSibling;\n\n\t\t\t\t\tvar current = text.dataset;\n\n\t\t\t\t\tif (current.hidden == \"true\") {\n\t\t\t\t\t\t(0, _core.$)(text).data(\"hidden\", false);\n\t\t\t\t\t\t(0, _core.$)(e.currentTarget).data(\"open\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(0, _core.$)(text).data(\"hidden\", true);\n\t\t\t\t\t\t(0, _core.$)(e.currentTarget).data(\"open\", false);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn Site_Build;\n}();\n\nvar Site = new Site_Build();\n\n//////////////////\n// WEBPACK FOOTER\n// ./main.js\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///./main.js?");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//////////////////\n// WEBPACK FOOTER\n// ./main.less\n// module id = 3\n// module chunks = 0\n\n//# sourceURL=webpack:///./main.less?");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = __webpack_require__(0);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _util = __webpack_require__(16);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar App_Build = function () {\n\tfunction App_Build() {\n\t\t_classCallCheck(this, App_Build);\n\n\t\tthis.extend(_events2.default);\n\t\tthis.extend(_util2.default);\n\t}\n\n\t_createClass(App_Build, [{\n\t\tkey: 'extend',\n\t\tvalue: function extend(obj) {\n\t\t\tObject.assign(this, obj);\n\t\t}\n\t}, {\n\t\tkey: 'methods',\n\t\tvalue: function methods(func) {\n\t\t\tObject.assign(this, func);\n\t\t}\n\t}, {\n\t\tkey: 'call',\n\t\tvalue: function call(methodName) {\n\t\t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\targs[_key - 1] = arguments[_key];\n\t\t\t}\n\n\t\t\tvar props = args[0];\n\n\t\t\tthis[methodName].call(this[methodName], props);\n\n\t\t\t//callback\n\t\t\tif (args.length - 1) {\n\t\t\t\targs[args.length - 1].call(props, props);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn App_Build;\n}();\n\nexports.default = App_Build;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/app/app.js\n// module id = 4\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/app/app.js?");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /*\r\n                                                                                                                                                                                                                                                                               * @description: A lightweight view library for creating components with \r\n                                                                                                                                                                                                                                                                               * Template Literals. Appending the Component tag before the template \r\n                                                                                                                                                                                                                                                                               * literal string, turns the string into and actual DOM element node.\r\n                                                                                                                                                                                                                                                                               * Using ES6 back tick template strings we can use multi-line strings \r\n                                                                                                                                                                                                                                                                               * to create the HTML template. Injecting data or dynamic properties \r\n                                                                                                                                                                                                                                                                               * are also possible using ${ - INSERT STRING OR OBJECT - }\r\n                                                                                                                                                                                                                                                                              */\n\nvar _literal = __webpack_require__(6);\n\nvar _literal2 = _interopRequireDefault(_literal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* \r\n * The HTML string used to create the component. Must be valid HTML. \r\n * Using tagged template literal syntax, dynamic values can be used \r\n * via '${value}'. Values can be either strings, elements or another \r\n * Component (which is also just an element). An element will be \r\n * coverted to a string and injected as innerHTML.\r\n*/\n\nvar Component = function Component(strings) {\n\tfor (var _len = arguments.length, exp = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\texp[_key - 1] = arguments[_key];\n\t}\n\n\t/*create new template from string*/\n\tvar taggedLiteral = new (Function.prototype.bind.apply(_literal2.default, [null].concat([strings], exp)))();\n\n\t/* return the DOM element to be appended */\n\treturn taggedLiteral;\n};\n\n/*\r\n * methods to extend to Component object\r\n*/\n\nvar methods = {\n\n\t/*\r\n  * component (DOM Element Node) : The declared component wished to render.\r\n  * DOMSelector (String) : The target element to render the component to. \r\n  * Can use string query syntax ('#id', '.class', *all', etc.), or an element \r\n  * stored in a variable (const target = $('#id').\r\n */\n\trender: function render(component, target, callback) {\n\t\tvar type = typeof target === \"undefined\" ? \"undefined\" : _typeof(target);\n\t\tif (type === \"string\") {\n\t\t\ttarget = document.querySelectorAll(target);\n\t\t\ttarget[0].appendChild(component.node);\n\t\t} else if (type === \"object\") {\n\t\t\tif (target instanceof HTMLElement) {\n\t\t\t\ttarget = [target];\n\t\t\t}\n\t\t\ttarget.forEach(function (node) {\n\t\t\t\tcomponent.node.appendChild(element);\n\t\t\t});\n\t\t} else {\n\t\t\tconsole.error(\"COMPONENT ERROR: Needs to be a valid DOM element or string selector.\");\n\t\t}\n\t\t//store the render target in the component\n\t\tComponent.renderTarget = target;\n\n\t\t//optional callback\n\t\tif (callback) {\n\t\t\tcallback();\n\t\t}\n\t},\n\n\n\t//element (DOM Element Node) : returns an HTML string of a element.\n\ttoStaticHTML: function toStaticHTML(element) {\n\t\tvar template = new _literal2.default();\n\n\t\treturn template.HTMLElementToString(element);\n\t}\n};\n\n//assign the methods to the main Component object\nObject.assign(Component, methods);\n\nexports.default = Component;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/component/component.js\n// module id = 5\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/component/component.js?");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Promise) {\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* \r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * create template class for decontructing tagged\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * template literal\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n\nvar _morphdom = __webpack_require__(17);\n\nvar _morphdom2 = _interopRequireDefault(_morphdom);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ComponentLiteral = function () {\n\tfunction ComponentLiteral(props) {\n\t\t_classCallCheck(this, ComponentLiteral);\n\n\t\tthis.componentLiteral = true;\n\t\tthis.node = {};\n\t\tthis.renderTarget = [];\n\n\t\tfor (var _len = arguments.length, exp = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\texp[_key - 1] = arguments[_key];\n\t\t}\n\n\t\tif (props.length > 0, exp.length > 0) {\n\t\t\tvar html = this.templateToString(props, exp);\n\n\t\t\tthis.node = this.toHTMLElement(html);\n\t\t} else {\n\t\t\tthis.renderTarget = props.renderTarget;\n\t\t\tthis.props = props;\n\n\t\t\tvar component = this.render();\n\n\t\t\tthis.node = component.node;\n\n\t\t\tif (component) {\n\t\t\t\tthis.staticHTML = component.staticHTML;\n\t\t\t\tthis.mountToDOM(component);\n\t\t\t}\n\t\t}\n\t}\n\n\t_createClass(ComponentLiteral, [{\n\t\tkey: \"toHTMLElement\",\n\t\tvalue: function toHTMLElement(string) {\n\n\t\t\t/*\r\n    * create dummy dom, look for child node\r\n    * and return the freshly created DOM node\r\n   */\n\n\t\t\tvar node = document.createElement(\"html\");\n\n\t\t\tnode.innerHTML = string;\n\t\t\tthis.staticHTML = string;\n\n\t\t\tnode = node.childNodes[1].childNodes[0];\n\n\t\t\treturn node;\n\t\t}\n\t}, {\n\t\tkey: \"HTMLElementToString\",\n\t\tvalue: function HTMLElementToString(component) {\n\n\t\t\t/*\r\n    * return the outer html of a node\r\n   */\n\n\t\t\treturn this.formatString(component.node.outerHTML);\n\t\t}\n\t}, {\n\t\tkey: \"beforeUpdate\",\n\t\tvalue: function beforeUpdate(func) {\n\n\t\t\tif (func) {\n\t\t\t\tfunc();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"update\",\n\t\tvalue: function update(next) {\n\t\t\tvar _this = this;\n\n\t\t\tvar promise = new Promise(function (resolve, reject) {\n\t\t\t\tif (_this.beforeUpdate()) {\n\t\t\t\t\t//efficiently updates the DOM from node to another\n\t\t\t\t\tresolve((0, _morphdom2.default)(_this.node, next.node));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tpromise.then(function () {\n\t\t\t\t_this.afterUpdate();\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"afterUpdate\",\n\t\tvalue: function afterUpdate(func) {\n\n\t\t\tif (func) {\n\t\t\t\tfunc();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: \"templateToString\",\n\t\tvalue: function templateToString(strings, exp) {\n\n\t\t\t/*\r\n    * parse and join the strings and data\r\n   */\n\n\t\t\tvar joined = strings.map(function (item, i) {\n\t\t\t\tif (exp[i]) {\n\n\t\t\t\t\tvar expression = exp[i];\n\t\t\t\t\tvar type = typeof expression === \"undefined\" ? \"undefined\" : _typeof(expression);\n\n\t\t\t\t\tif (type === \"object\" && Array.isArray(expression) && expression[0].componentLiteral) {\n\t\t\t\t\t\texpression = expression.map(function (object) {\n\t\t\t\t\t\t\treturn object.staticHTML;\n\t\t\t\t\t\t}).join(\"\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn item + expression;\n\t\t\t\t}\n\n\t\t\t\treturn item;\n\t\t\t}).join(\"\");\n\n\t\t\tjoined = this.formatString(joined);\n\n\t\t\treturn joined;\n\t\t}\n\t}, {\n\t\tkey: \"formatString\",\n\t\tvalue: function formatString(str) {\n\n\t\t\t/*\r\n    * remove all whitespace, tabs and return lines from string\r\n   */\n\n\t\t\treturn str.replace(/\\r?\\n|\\r/g, \"\").replace(/\\t/g, \"\");\n\t\t}\n\t}, {\n\t\tkey: \"mountToDOM\",\n\t\tvalue: function mountToDOM(element) {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar target = this.renderTarget;\n\n\t\t\tvar type = _typeof(this.renderTarget);\n\n\t\t\tif (type === \"string\") {\n\t\t\t\ttarget = document.querySelectorAll(target);\n\n\t\t\t\ttarget[0].appendChild(this.node);\n\t\t\t} else if (type === \"object\") {\n\n\t\t\t\tif (target instanceof HTMLElement) {\n\t\t\t\t\ttarget = [target];\n\t\t\t\t}\n\t\t\t\ttarget.forEach(function (node) {\n\t\t\t\t\t_this2.node.appendChild(element);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconsole.error(\"COMPONENT ERROR: Needs to be a valid DOM element or string selector.\");\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"render\",\n\t\tvalue: function render() {\n\t\t\t/* return html */\n\t\t}\n\t}]);\n\n\treturn ComponentLiteral;\n}();\n\nexports.default = ComponentLiteral;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/component/literal.js\n// module id = 6\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/component/literal.js?");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DOM_Methods = function DOM_Methods() {\n\t_classCallCheck(this, DOM_Methods);\n\n\tthis.methods = {\n\t\taddClass: function addClass(className) {\n\t\t\tthis.forEach(function (node) {\n\t\t\t\tif (node.classList) {\n\t\t\t\t\tnode.classList.add(className);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\tremoveClass: function removeClass(className) {\n\t\t\tthis.forEach(function (node) {\n\t\t\t\tnode.classList.remove(className);\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\tdata: function data(attributeName, value) {\n\t\t\tthis.forEach(function (node) {\n\t\t\t\tnode.setAttribute(\"data-\" + attributeName, value);\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\tfind: function find(target) {\n\t\t\tvar searchTarget = {};\n\t\t\tthis.forEach(function (node) {\n\t\t\t\tsearchTarget = node.querySelectorAll(target);\n\t\t\t});\n\t\t\treturn searchTarget;\n\t\t},\n\t\thtml: function html(string) {\n\t\t\tthis.forEach(function (node) {\n\t\t\t\tnode.innerHTML = string;\n\t\t\t});\n\t\t\treturn this;\n\t\t},\n\t\ton: function on(event, func) {\n\t\t\tthis.forEach(function (node) {\n\t\t\t\tnode.addEventListener(event, func);\n\t\t\t});\n\t\t},\n\t\tappend: function append(element) {},\n\t\tready: function ready(func) {\n\t\t\tthis.forEach(function (node) {\n\t\t\t\tnode.addEventListener(\"DOMContentLoaded\", func);\n\t\t\t});\n\t\t}\n\t};\n};\n\nvar HTML_Element = function (_DOM_Methods) {\n\t_inherits(HTML_Element, _DOM_Methods);\n\n\tfunction HTML_Element(elem) {\n\t\t_classCallCheck(this, HTML_Element);\n\n\t\tvar _this = _possibleConstructorReturn(this, (HTML_Element.__proto__ || Object.getPrototypeOf(HTML_Element)).call(this));\n\n\t\t_this.node = elem;\n\t\t_this.node.isRendered = false;\n\n\t\t/* test if class name is found within body */\n\t\tif (_this.node.length !== 0) {\n\t\t\t_this.node.isRendered = true;\n\t\t}\n\n\t\tObject.assign(_this.node, _this.methods);\n\t\treturn _this;\n\t}\n\n\treturn HTML_Element;\n}(DOM_Methods);\n\nvar $ = function $(selector) {\n\tvar elem = [selector];\n\n\tvar type = typeof selector === \"undefined\" ? \"undefined\" : _typeof(selector);\n\n\tif (type === \"object\") {\n\t\telem = new HTML_Element(elem);\n\t} else if (type === \"string\") {\n\t\telem = new HTML_Element(document.querySelectorAll(selector));\n\t} else {\n\t\tconsole.error(\"DOM: Not a valid selector. Must be a string selector (., #, *, etc.) or a dom element\");\n\t}\n\n\treturn elem.node;\n};\n\nexports.default = $;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/dom/dom.js\n// module id = 7\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/dom/dom.js?");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.$ = exports.App_Build = exports.Scrollmap = exports.App_Router = exports.Component = exports.Storage = exports.Events = undefined;\n\nvar _events = __webpack_require__(0);\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _storage = __webpack_require__(14);\n\nvar Storage = _interopRequireWildcard(_storage);\n\nvar _router = __webpack_require__(9);\n\nvar _router2 = _interopRequireDefault(_router);\n\nvar _component = __webpack_require__(5);\n\nvar _component2 = _interopRequireDefault(_component);\n\nvar _scrollmap = __webpack_require__(10);\n\nvar _scrollmap2 = _interopRequireDefault(_scrollmap);\n\nvar _app = __webpack_require__(4);\n\nvar _app2 = _interopRequireDefault(_app);\n\nvar _dom = __webpack_require__(7);\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Events = _events2.default;\nexports.Storage = Storage;\nexports.Component = _component2.default;\nexports.App_Router = _router2.default;\nexports.Scrollmap = _scrollmap2.default;\nexports.App_Build = _app2.default;\nexports.$ = _dom2.default; /**\r\n                            *\r\n                            * @public\r\n                            * @namespace core\r\n                            * @description Holds the different core modules.\r\n                            *\r\n                            */\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/index.js\n// module id = 8\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/index.js?");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar App_Router = function () {\n\tfunction App_Router() {\n\t\t_classCallCheck(this, App_Router);\n\n\t\tthis.params = this.getQueryParameters();\n\t\tthis.routes = [];\n\t\tthis.currentRoute = window.location.pathname;\n\t\tthis.checkRoute();\n\t}\n\n\t_createClass(App_Router, [{\n\t\tkey: \"getQueryParameters\",\n\t\tvalue: function getQueryParameters(str) {\n\n\t\t\t/* \r\n    * @desc get the query paramers from search and convert to object\r\n   */\n\n\t\t\treturn (str || document.location.search).replace(/(^\\?)/, '').split(\"&\").map(function (n) {\n\t\t\t\tn = n.split(\"=\");\n\t\t\t\tn = this[n[0]] = n[1];\n\n\t\t\t\treturn this;\n\t\t\t}.bind({}))[0];\n\t\t}\n\t}, {\n\t\tkey: \"go\",\n\t\tvalue: function go(pathName) {\n\t\t\twindow.location.pathname = pathName;\n\t\t}\n\t}, {\n\t\tkey: \"route\",\n\t\tvalue: function route(pathName, controller) {\n\t\t\tvar route = {\n\t\t\t\tpathName: pathName,\n\t\t\t\tcontroller: controller\n\t\t\t};\n\n\t\t\tthis.routes.push(route);\n\t\t}\n\t}, {\n\t\tkey: \"checkRoute\",\n\t\tvalue: function checkRoute() {\n\t\t\tvar _this = this;\n\n\t\t\tthis.routes.forEach(function (item) {\n\t\t\t\tif (_this.currentRoute === item.pathName) {\n\t\t\t\t\titem.controller();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn App_Router;\n}();\n\n;\n\nexports.default = App_Router;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/router/router.js\n// module id = 9\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/router/router.js?");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _trigger = __webpack_require__(11);\n\nvar _trigger2 = _interopRequireDefault(_trigger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n *\r\n * @namespace scrollMap\r\n * @description store element points and check if\r\n * elements are visible\r\n *\r\n*/\n\nvar Scroll_Event_Trigger = function () {\n    function Scroll_Event_Trigger() {\n        _classCallCheck(this, Scroll_Event_Trigger);\n\n        this.lastScrollTop = 0;\n        this.points = [];\n        this.events();\n    }\n\n    _createClass(Scroll_Event_Trigger, [{\n        key: \"add\",\n        value: function add(el, callback) {\n            var _this = this;\n\n            /* \r\n             * @desc add classname indicating element is intialized\r\n             */\n\n            var type = typeof el === \"undefined\" ? \"undefined\" : _typeof(el);\n\n            if (type === \"string\") {\n                el = document.querySelectorAll(el);\n            } else if (type === \"object\") {\n                el = [el];\n            }\n\n            el.forEach(function (node) {\n                node.setAttribute(\"data-scrollmap-loaded\", true);\n\n                var point = new _trigger2.default(node, callback);\n\n                _this.points.push(point);\n            });\n        }\n    }, {\n        key: \"remove\",\n        value: function remove(trigger) {\n            trigger = null;\n        }\n    }, {\n        key: \"elementInViewport\",\n        value: function elementInViewport(el, percetageOfElement) {\n\n            /*\r\n             * @desc check if element is in viewport\r\n            */\n\n            /*\r\n             * look for direction of scroll and base element visible\r\n             * percentage off of either top bottom when scrolling\r\n             * down, or the top when scrolling up. This may not be\r\n             * the perfect method but is cross browser compatible.\r\n            */\n\n            var rect = el.getBoundingClientRect();\n\n            var stats = {\n                top: rect.top - window.innerHeight,\n                bottom: rect.bottom + rect.height,\n                height: rect.height\n            };\n\n            var amount = stats.height * percetageOfElement;\n\n            if (stats.bottom - amount > stats.height && stats.top + amount < 0) {\n                return true;\n            }\n\n            return false;\n        }\n    }, {\n        key: \"checkVisible\",\n        value: function checkVisible(point) {\n            var targetElement = point.element;\n            var viewport = this.elementInViewport(targetElement, point.surfaceVisible);\n\n            if (viewport) {\n                targetElement.setAttribute(\"data-is-visible\", true);\n\n                if (point.onTriggerIn) {\n                    point.onTriggerIn();\n                }\n            } else {\n                targetElement.setAttribute(\"data-is-visible\", false);\n\n                if (point.onTriggerOut) {\n                    point.onTriggerOut();\n                }\n            }\n        }\n    }, {\n        key: \"on\",\n        value: function on(string, callback) {\n\n            /*\r\n             * methods for creating various listeners\r\n            */\n\n            var direction = this.scrollOrient;\n\n            if (direction === \"Up\" && string === \"scrollUp\") {\n                callback();\n            }\n\n            if (direction === \"Down\" && string === \"scrollDown\") {\n                callback();\n            }\n        }\n    }, {\n        key: \"scrollDirection\",\n        value: function scrollDirection() {\n\n            /*\r\n             * return the scroll direction via a string value\r\n            */\n\n            var direction = \"\";\n\n            var st = window.pageYOffset || document.documentElement.scrollTop;\n\n            if (st > this.lastScrollTop) {\n                direction = \"Down\";\n            } else {\n                direction = \"Up\";\n            }\n\n            this.lastScrollTop = st;\n\n            return direction;\n        }\n    }, {\n        key: \"extend\",\n        value: function extend(obj) {\n            Object.assign(this, obj);\n        }\n    }, {\n        key: \"events\",\n        value: function events() {\n            var _this2 = this;\n\n            //initial check on page load to see if elements are visible\n            window.onload = function () {\n                _this2.points.forEach(function (point) {\n                    _this2.checkVisible(point);\n                });\n            };\n\n            //check for visible elements on scroll\n            window.addEventListener(\"scroll\", function () {\n                _this2.scrollOrient = _this2.scrollDirection();\n\n                _this2.points.forEach(function (point) {\n                    _this2.checkVisible(point);\n                });\n            });\n        }\n    }]);\n\n    return Scroll_Event_Trigger;\n}();\n\n;\n\nvar Scrollmap = new Scroll_Event_Trigger();\n\nexports.default = Scrollmap;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/scrollmap/scrollmap.js\n// module id = 10\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/scrollmap/scrollmap.js?");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Trigger = function () {\n\tfunction Trigger(element, options) {\n\t\t_classCallCheck(this, Trigger);\n\n\t\tthis.element = element;\n\t\tthis.surfaceVisible = 1;\n\n\t\tif (options) {\n\t\t\tObject.assign(this, options);\n\t\t}\n\t}\n\n\t_createClass(Trigger, [{\n\t\tkey: \"destroy\",\n\t\tvalue: function destroy() {\n\t\t\tthis.element = null;\n\t\t\tthis.isDestroyed = true;\n\t\t}\n\t}]);\n\n\treturn Trigger;\n}();\n\nexports.default = Trigger;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/scrollmap/trigger.js\n// module id = 11\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/scrollmap/trigger.js?");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Collection = function () {\n\tfunction Collection(name) {\n\t\t_classCallCheck(this, Collection);\n\n\t\tthis.name = name;\n\t\tthis.verify();\n\t}\n\n\t_createClass(Collection, [{\n\t\tkey: 'verify',\n\t\tvalue: function verify() {\n\t\t\tvar exists = this.get(this.name);\n\n\t\t\tif (!exists) {\n\t\t\t\tthis.collection_id = this._id(this.name);\n\t\t\t\tthis.items = [];\n\n\t\t\t\tthis.create(this.name);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'create',\n\t\tvalue: function create(key) {\n\t\t\tlocalStorage.setItem(key, JSON.stringify(this));\n\t\t}\n\t}, {\n\t\tkey: '_id',\n\t\tvalue: function _id() {\n\t\t\treturn '_' + (Date.now().toString(36) + Math.random().toString(36).substr(2, 5));\n\t\t}\n\t}, {\n\t\tkey: 'add',\n\t\tvalue: function add(value) {\n\t\t\tvar id = { _id: this._id() };\n\n\t\t\tObject.assign(value, id);\n\t\t\tvar db = this.get(this.name);\n\n\t\t\tdb.items.push(value);\n\t\t\tlocalStorage.setItem(this.name, JSON.stringify(db));\n\t\t}\n\t}, {\n\t\tkey: 'get',\n\t\tvalue: function get(key) {\n\t\t\tvar item = localStorage.getItem(key);\n\n\t\t\treturn JSON.parse(item);\n\t\t}\n\t}, {\n\t\tkey: 'remove',\n\t\tvalue: function remove(key) {\n\t\t\tlocalStorage.removeItem(key);\n\t\t}\n\t}, {\n\t\tkey: 'store',\n\t\tvalue: function store() {\n\t\t\tlocalStorage.setItem(this.name, JSON.stringify(this));\n\t\t}\n\t}]);\n\n\treturn Collection;\n}();\n\nexports.default = Collection;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/storage/collection.js\n// module id = 12\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/storage/collection.js?");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\r\n *\r\n * @public\r\n * @description browser cookie store and retrieve\r\n *\r\n */\n\nvar Cookie = {\n\tset: function set(cname, cvalue, exdays) {\n\t\tvar d = new Date();\n\n\t\td.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);\n\n\t\tvar expires = \"expires=\" + d.toUTCString();\n\n\t\tdocument.cookie = cname + \"=\" + cvalue + \"; \" + expires;\n\t},\n\tget: function get(cname) {\n\t\tvar name = cname + \"=\";\n\n\t\tvar ca = document.cookie.split(';');\n\n\t\tfor (var i = 0; i < ca.length; i++) {\n\t\t\tvar c = ca[i];\n\n\t\t\twhile (c.charAt(0) === ' ') {\n\t\t\t\tc = c.substring(1);\n\t\t\t}\n\t\t\tif (c.indexOf(name) === 0) {\n\t\t\t\treturn c.substring(name.length, c.length);\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n};\n\nexports.default = Cookie;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/storage/cookie.js\n// module id = 13\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/storage/cookie.js?");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.local = exports.Session = exports.Cookie = undefined;\n\nvar _cookie = __webpack_require__(13);\n\nvar _cookie2 = _interopRequireDefault(_cookie);\n\nvar _session = __webpack_require__(15);\n\nvar _session2 = _interopRequireDefault(_session);\n\nvar _collection = __webpack_require__(12);\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Cookie = _cookie2.default;\nexports.Session = _session2.default;\nexports.local = _collection2.default;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/storage/index.js\n// module id = 14\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/storage/index.js?");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\r\n *\r\n * @public\r\n * @description session store and retrieve\r\n *\r\n */\n\nvar Session = {\n\tset: function set(key, value) {\n\t\tsessionStorage.setItem(key, JSON.stringify(value));\n\t},\n\tget: function get(key) {\n\t\tvar item = sessionStorage.getItem(key);\n\n\t\treturn JSON.parse(item);\n\t}\n};\n\nexports.default = Session;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/storage/session.js\n// module id = 15\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/core/storage/session.js?");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n});\nvar Util = {\n\t\tslugify: function slugify(filterName) {\n\n\t\t\t\t/*\r\n     * @desc turn string into slug\r\n    */\n\n\t\t\t\treturn filterName.toLowerCase().replace(/ /g, \"-\").replace(/-&-/g, \"-\");\n\t\t},\n\t\tisMobile: function isMobile() {\n\t\t\t\tvar isMobile = false; //initiate as false\n\t\t\t\t// device detection\n\t\t\t\tif (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(navigator.userAgent.substr(0, 4))) isMobile = true;\n\n\t\t\t\treturn isMobile;\n\t\t}\n};\n\nexports.default = Util;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/util.js\n// module id = 16\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/util/util.js?");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\n\nvar testEl = doc ?\n    doc.body || doc.createElement('div') :\n    {};\n\n// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>\n// (IE7+ support) <=IE7 does not support el.hasAttribute(name)\nvar actualHasAttributeNS;\n\nif (testEl.hasAttributeNS) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttributeNS(namespaceURI, name);\n    };\n} else if (testEl.hasAttribute) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttribute(name);\n    };\n} else {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.getAttributeNode(namespaceURI, name) != null;\n    };\n}\n\nvar hasAttributeNS = actualHasAttributeNS;\n\n\nfunction toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!hasAttributeNS(toNode, attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!hasAttributeNS(toNode, null, attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name, '');\n        }\n    }\n}\n\nvar specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!hasAttributeNS(toEl, null, 'value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!hasAttributeNS(toEl, null, 'multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                var nodeName = curChild.nodeName;\n                if (nodeName && nodeName.toUpperCase() === 'OPTION') {\n                    if (hasAttributeNS(curChild, null, 'selected')) {\n                        selectedIndex = i;\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                morphAttrs(fromEl, toEl);\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = getNodeKey(curToNodeChild);\n\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (curFromNodeChild.nextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's moving the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    morphEl(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    }\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        morphEl(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphEl(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    morphedNode.nodeValue = toNode.nodeValue;\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nmodule.exports = morphdom;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/morphdom/dist/morphdom.js\n// module id = 17\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/morphdom/dist/morphdom.js?");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 18\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/process/browser.js?");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 19\n// module chunks = 0\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//////////////////\n// WEBPACK FOOTER\n// vertx (ignored)\n// module id = 20\n// module chunks = 0\n\n//# sourceURL=webpack:///vertx_(ignored)?");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(2);\nmodule.exports = __webpack_require__(3);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi ./main.js ./main.less\n// module id = 21\n// module chunks = 0\n\n//# sourceURL=webpack:///multi_./main.js_./main.less?");

/***/ })
/******/ ]);